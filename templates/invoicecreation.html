{% extends 'base.html' %}
{% import '_components.html' as ui %}
{% block content %}
  <h1>{{ t('invoice_title') }}</h1>
  <form id="invoice_form" method="post" action="{{ url_for('api_generate_invoice') }}" enctype="multipart/form-data">
    {% call ui.card() %}
      {% call ui.field(t('dropdown_label_search'), 'client_name') %}
        <div class="combo" style="position:relative;">
          <input type="text" id="combo_input" placeholder="{{ t('search_placeholder') }}" autocomplete="off">
          <input type="hidden" id="client_name" name="client_name" required>
          <div id="combo_list" class="combo-list" style="position:absolute; z-index:10; width:100%; max-height:220px; overflow:auto; display:none;"></div>
        </div>
      {% endcall %}
      {% call ui.field(t('invoice_name'), 'invoice_name') %}
        <input type="text" id="invoice_name" name="invoice_name" placeholder="{{ t('invoice_name_placeholder') }}">
        <div id="invoice_name_hint" style="margin-top:6px; font-size:0.9em; display:none;"></div>
        <div id="invoice_name_suggestions" style="margin-top:4px; display:none;"></div>
      {% endcall %}
      {% call ui.field(t('title_label'), 'titleInvoice') %}
        <input type="text" id="titleInvoice" name="titleInvoice" placeholder="{{ t('title_placeholder') }}" maxlength="1000" style="width:100%;">
        <div id="titleInvoice_hint" style="margin-top:6px; font-size:0.9em; color:#666;"></div>
      {% endcall %}
      {% call ui.field(t('header_label'), 'headerInvoice') %}
        <textarea id="headerInvoice" name="headerInvoice" rows="5" placeholder="{{ t('header_placeholder') }}" style="width:100%; resize:vertical; max-height:220px; overflow:auto; border-radius:8px; background:#1e1e1e; color:#ffffff; padding:10px; border:1px solid #444;"></textarea>
      {% endcall %}
      {% call ui.field(t('delivery_label'), 'delivery_notes') %}
        <input type="file" id="delivery_notes" name="delivery_notes" accept=".pdf" multiple>
      {% endcall %}
      {% call ui.field(t('currency'), 'currency_code') %}
        <select id="currency_code" name="currency_code">
          <option value="CHF">CHF</option>
          <option value="EUR">EUR</option>
          <option value="USD">USD</option>
          <option value="GBP">GBP</option>
          <option value="BRL">BRL</option>
          <option value="JPY">JPY</option>
          <option value="CNY">CNY</option>
        </select>
        <input type="hidden" id="currency_exchange" name="currency_exchange" value="">
      {% endcall %}
      {{ ui.button(t('generate_button'), attrs='id="generate_btn" type="submit"') }}
      <div id="eta_msg" style="display:none; margin-top:6px; font-size:0.9em; opacity:0.8;"></div>
    {% endcall %}
  </form>
  <div id="result_panel" style="display:none; margin-top:16px;"></div>
  <script>
    const comboInput = document.getElementById('combo_input');
    const comboList = document.getElementById('combo_list');
    const hiddenInput = document.getElementById('client_name');
    const invoiceForm = document.getElementById('invoice_form');
    const generateBtn = document.getElementById('generate_btn');
    const resultPanel = document.getElementById('result_panel');
    const invoiceNameEl = document.getElementById('invoice_name');
    const invoiceNameHint = document.getElementById('invoice_name_hint');
    const invoiceNameSug = document.getElementById('invoice_name_suggestions');
    const deliveryNotesInput = document.getElementById('delivery_notes');
    const currencySelect = document.getElementById('currency_code');
    const currencyExchangeInput = document.getElementById('currency_exchange');
    const etaMsg = document.getElementById('eta_msg');
    let etaInterval = null;
    let items = [];
    let open = false;
    let timer = null;
    let nameTimer = null;
    let titleTimer = null;

    function openList(){ comboList.style.display = 'block'; open = true; }
    function closeList(){ comboList.style.display = 'none'; open = false; }
    function renderList(filter){
      comboList.innerHTML = '';
      const q = (filter || '').toLowerCase();
      // Textual search: split query into tokens AND do accent-insensitive compare
      const normalize = (s) => (s || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      const tokens = normalize(q).split(/\s+/).filter(Boolean);
      const filtered = tokens.length ? items.filter(v => {
        const s = normalize(v);
        return tokens.every(t => s.includes(t));
      }) : items;
      if(filtered.length === 0){ closeList(); return; }
      filtered.forEach(v => {
        const opt = document.createElement('div');
        opt.textContent = v;
        opt.className = 'combo-item';
        opt.style.padding = '8px';
        opt.style.cursor = 'pointer';
        opt.addEventListener('mousedown', () => { // mousedown to fire before input blur
          comboInput.value = v;
          hiddenInput.value = v;
          closeList();
        });
        comboList.appendChild(opt);
      });
    }
    async function fetchCustomers(q){
      const url = q ? (`/api/customers?q=` + encodeURIComponent(q)) : '/api/customers';
      const resp = await fetch(url);
      if(!resp.ok) return;
      items = await resp.json();
      renderList(q);
    }
    comboInput.addEventListener('input', () => {
      hiddenInput.value = '';
      if(timer) clearTimeout(timer);
      const q = comboInput.value.trim();
      // local filter immediately for fast UX
      renderList(q);
      // also refresh from server after debounce to support backend filtering
      timer = setTimeout(() => fetchCustomers(q), 250);
      openList();
    });
    comboInput.addEventListener('click', () => {
      // toggle open on click without auto-opening on page load
      if(comboList.style.display === 'block'){ closeList(); }
      else { renderList(comboInput.value.trim()); openList(); }
    });
    comboInput.addEventListener('focus', () => { fetchCustomers(comboInput.value.trim()); });
    comboInput.addEventListener('blur', () => setTimeout(closeList, 100));
    // preload (do not open)
    fetchCustomers('');

    // Currency rounding configuration and FX helpers
    const CCY_ROUNDING = {
      CHF: 0.05,
      EUR: 0.01,
      USD: 0.01,
      GBP: 0.01,
      BRL: 0.01,
      JPY: 0.01,
      CNY: 0.01,
    };

    async function fetchFxFromFrankfurter(code){
      // Frankfurter returns last business day on weekends
      const url = `https://api.frankfurter.app/latest?from=CHF&to=${encodeURIComponent(code)}`;
      const resp = await fetch(url);
      if(!resp.ok) throw new Error('Frankfurter error');
      const data = await resp.json();
      const rate = data && data.rates && data.rates[code];
      if(typeof rate !== 'number') throw new Error('Frankfurter missing rate');
      return { rate, asOf: data.date, provider: 'Frankfurter', quoteType: 'ECB daily' };
    }

    async function fetchFxFromHost(code){
      // exchangerate.host fallback (free, no key)
      const url = `https://api.exchangerate.host/latest?base=CHF&symbols=${encodeURIComponent(code)}`;
      const resp = await fetch(url);
      if(!resp.ok) throw new Error('exchangerate.host error');
      const data = await resp.json();
      const rate = data && data.rates && data.rates[code];
      if(typeof rate !== 'number') throw new Error('exchangerate.host missing rate');
      // exchangerate.host returns date in data.date as well
      return { rate, asOf: data.date || new Date().toISOString().slice(0,10), provider: 'exchangerate.host', quoteType: 'aggregated' };
    }

    async function resolveCurrencyExchange(code){
      if(code === 'CHF'){
        return {
          base: 'CHF',
          code: 'CHF',
          rate: 1.00,
          asOf: new Date().toISOString().slice(0,10),
          provider: 'static',
          quoteType: 'identity',
          rounding: CCY_ROUNDING['CHF'] || 0.05,
          precision: 6,
        };
      }
      try{
        const res = await fetchFxFromFrankfurter(code);
        return {
          base: 'CHF',
          code,
          rate: res.rate,
          asOf: res.asOf,
          provider: res.provider,
          quoteType: res.quoteType,
          rounding: CCY_ROUNDING[code] || 0.01,
          precision: 6,
        };
      } catch(_e){
        const res = await fetchFxFromHost(code);
        return {
          base: 'CHF',
          code,
          rate: res.rate,
          asOf: res.asOf,
          provider: res.provider,
          quoteType: res.quoteType,
          rounding: CCY_ROUNDING[code] || 0.01,
          precision: 6,
        };
      }
    }

    function formatMMSS(totalSeconds){
      const m = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
      const s = Math.floor(totalSeconds % 60).toString().padStart(2, '0');
      return `${m}:${s}`;
    }

    function startEtaCountdown(){
      if(etaInterval){ clearInterval(etaInterval); etaInterval = null; }
      const files = deliveryNotesInput && deliveryNotesInput.files ? deliveryNotesInput.files : null;
      const count = files ? files.length : 0;
      // Count up: elapsed time from request start until response
      let seconds = 0;
      const label = "{{ t('eta_label') }}";
      const updateView = () => {
        etaMsg.textContent = `${label} ${formatMMSS(seconds)}`;
      };
      etaMsg.style.display = 'block';
      updateView();
      etaInterval = setInterval(() => {
        seconds += 1;
        updateView();
      }, 1000);
    }

    function setLoading(isLoading){
      if(isLoading){
        generateBtn.disabled = true;
        const txt = generateBtn.textContent;
        generateBtn.dataset.prev = txt;
        generateBtn.textContent = "{{ t('please_wait') }}";
        generateBtn.classList.add('loading');
        startEtaCountdown();
      } else {
        generateBtn.disabled = false;
        generateBtn.textContent = generateBtn.dataset.prev || "{{ t('generate_button') }}";
        generateBtn.classList.remove('loading');
        if(etaInterval){ clearInterval(etaInterval); etaInterval = null; }
        if(etaMsg){ etaMsg.style.display = 'none'; etaMsg.textContent = ''; }
      }
    }

    function stripTrailingPdf(name){
      if(!name) return '';
      const s = String(name);
      return s.toLowerCase().endsWith('.pdf') ? s.slice(0, -4) : s;
    }

    // Title word counter (non-blocking guidance)
    const titleEl = document.getElementById('titleInvoice');
    const titleHint = document.getElementById('titleInvoice_hint');
    function updateTitleHint(){
      if(!titleEl || !titleHint) return;
      const words = (titleEl.value || '').trim().split(/\s+/).filter(Boolean);
      const count = words.length;
      titleHint.textContent = '';
    }
    if(titleEl){
      updateTitleHint();
      titleEl.addEventListener('input', () => {
        if(titleTimer) clearTimeout(titleTimer);
        titleTimer = setTimeout(updateTitleHint, 150);
      });
    }

    function setNameHintAvailable(){
      if(!invoiceNameHint) return;
      invoiceNameHint.style.display = 'block';
      invoiceNameHint.style.color = '#0a7f2e';
      invoiceNameHint.textContent = "{{ t('name_available') }}";
    }

    function setNameHintTaken(){
      if(!invoiceNameHint) return;
      invoiceNameHint.style.display = 'block';
      invoiceNameHint.style.color = '#a31212';
      invoiceNameHint.textContent = "{{ t('name_taken') }}";
    }

    function clearNameHint(){
      if(invoiceNameHint){ invoiceNameHint.style.display = 'none'; invoiceNameHint.textContent=''; }
      if(invoiceNameSug){ invoiceNameSug.style.display = 'none'; invoiceNameSug.innerHTML=''; }
    }

    function renderNameSuggestions(suggestions){
      if(!invoiceNameSug) return;
      invoiceNameSug.innerHTML = '';
      if(!suggestions || !suggestions.length){
        invoiceNameSug.style.display = 'none';
        return;
      }
      invoiceNameSug.style.display = 'block';
      suggestions.slice(0,3).forEach(s => {
        const a = document.createElement('a');
        a.href = '#';
        a.textContent = s;
        a.style.marginRight = '8px';
        a.addEventListener('click', (ev) => {
          ev.preventDefault();
          invoiceNameEl.value = s;
          // trigger recheck immediately
          checkInvoiceNameAvailability(s);
        });
        invoiceNameSug.appendChild(a);
      });
    }

    async function checkInvoiceNameAvailability(raw){
      const v = stripTrailingPdf((raw ?? invoiceNameEl.value).trim());
      if(!v){ clearNameHint(); return { available: true }; }
      try{
        const resp = await fetch(`/api/invoices/check-name?name=${encodeURIComponent(v)}`);
        if(!resp.ok){ clearNameHint(); return { available: true }; }
        const data = await resp.json();
        if(data.available){
          setNameHintAvailable();
          renderNameSuggestions([]);
        } else {
          setNameHintTaken();
          renderNameSuggestions(data.suggestions || []);
        }
        return data;
      } catch(_e){
        clearNameHint();
        return { available: true };
      }
    }

    invoiceNameEl.addEventListener('input', () => {
      if(nameTimer) clearTimeout(nameTimer);
      const raw = invoiceNameEl.value;
      if(!raw || !raw.trim()){ clearNameHint(); return; }
      nameTimer = setTimeout(() => { checkInvoiceNameAvailability(raw); }, 350);
    });

    invoiceForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      if(!hiddenInput.value){ return; }
      // Recheck availability on submit to avoid race
      const check = await checkInvoiceNameAvailability(invoiceNameEl.value);
      if(check && check.available === false){
        // Do not proceed; guide user
        return;
      }
      const fd = new FormData(invoiceForm);
      // Include Title and Header as provided; no extra normalization
      // (backend will forward as-is)
      // ensure we don't pass .pdf in Invoice_name server side already handles, but keep raw user value
      setLoading(true);
      resultPanel.style.display = 'none';
      resultPanel.innerHTML = '';
      try{
        // Resolve currency exchange before sending
        const selectedCode = (currencySelect && currencySelect.value) ? currencySelect.value : 'CHF';
        const cx = await resolveCurrencyExchange(selectedCode);
        if(currencyExchangeInput){ currencyExchangeInput.value = JSON.stringify(cx); }
        fd.set('currency_exchange', JSON.stringify(cx));
        const resp = await fetch(invoiceForm.action, { method: 'POST', body: fd });
        const data = await resp.json().catch(() => ({}));
        if(!resp.ok){
          alert(data.error || "{{ t('request_failed') }}");
          return;
        }
        // Update invoice name if not set
        if(!invoiceNameEl.value && data.name){ invoiceNameEl.value = data.name; }
        resultPanel.style.display = 'block';
        resultPanel.innerHTML = `
          <div class="card">
            <div class="card-body">
              <div style="margin-bottom:8px;">${data.name || 'invoice.pdf'}</div>
              <a class="btn" href="${data.preview_url}" target="_blank">{{ t('preview') }}</a>
              <a class="btn btn-primary" href="${data.download_url}">{{ t('download') }}</a>
            </div>
          </div>`;
      } catch(err){
        alert(err?.message || "{{ t('error_generic') }}");
      } finally {
        setLoading(false);
      }
    });
  </script>
{% endblock %}


